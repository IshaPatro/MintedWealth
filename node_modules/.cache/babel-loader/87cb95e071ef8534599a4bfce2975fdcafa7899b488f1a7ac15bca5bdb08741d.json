{"ast":null,"code":"// src/index.tsx\nimport * as React from \"react\";\nimport { useContext, useState, useRef, useEffect } from \"react\";\nimport { useMemoOne, useOnce, raf } from \"@react-spring/shared\";\nimport { a, Controller, config as configs } from \"@react-spring/web\";\nvar ParentContext = React.createContext(null);\nfunction getScrollType(horizontal) {\n  return horizontal ? \"scrollLeft\" : \"scrollTop\";\n}\nfunction mapChildrenRecursive(children, callback) {\n  const isReactFragment = node => {\n    if (node.type) {\n      return node.type === React.Fragment;\n    }\n    return node === React.Fragment;\n  };\n  return React.Children.map(children, child => isReactFragment(child) ? mapChildrenRecursive(child.props.children, callback) : callback(child));\n}\nvar START_TRANSLATE_3D = \"translate3d(0px,0px,0px)\";\nvar START_TRANSLATE = \"translate(0px,0px)\";\nvar ParallaxLayer = React.memo(React.forwardRef((_ref, ref) => {\n  let {\n    horizontal,\n    factor = 1,\n    offset = 0,\n    speed = 0,\n    sticky,\n    ...rest\n  } = _ref;\n  const parent = useContext(ParentContext);\n  const ctrl = useMemoOne(() => {\n    let translate;\n    if (sticky) {\n      const start = sticky.start || 0;\n      translate = start * parent.space;\n    } else {\n      const targetScroll = Math.floor(offset) * parent.space;\n      const distance = parent.space * offset + targetScroll * speed;\n      translate = -(parent.current * speed) + distance;\n    }\n    return new Controller({\n      space: sticky ? parent.space : parent.space * factor,\n      translate\n    });\n  }, []);\n  const layer = useMemoOne(() => ({\n    horizontal: horizontal === void 0 || sticky ? parent.horizontal : horizontal,\n    sticky: void 0,\n    isSticky: false,\n    setPosition(height, scrollTop) {\n      let immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (sticky) {\n        setSticky(height, scrollTop);\n      } else {\n        const targetScroll = Math.floor(offset) * height;\n        const distance = height * offset + targetScroll * speed;\n        ctrl.start({\n          translate: -(scrollTop * speed) + distance,\n          config: parent.config,\n          immediate\n        });\n      }\n    },\n    setHeight(height) {\n      let immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      ctrl.start({\n        space: sticky ? height : height * factor,\n        config: parent.config,\n        immediate\n      });\n    }\n  }), []);\n  useOnce(() => {\n    if (sticky) {\n      const start = sticky.start || 0;\n      const end = sticky.end || start + 1;\n      layer.sticky = {\n        start,\n        end\n      };\n    }\n  });\n  React.useImperativeHandle(ref, () => layer);\n  const layerRef = useRef();\n  const setSticky = (height, scrollTop) => {\n    const start = layer.sticky.start * height;\n    const end = layer.sticky.end * height;\n    const isSticky = scrollTop >= start && scrollTop <= end;\n    if (isSticky === layer.isSticky) return;\n    layer.isSticky = isSticky;\n    const ref2 = layerRef.current;\n    ref2.style.position = isSticky ? \"sticky\" : \"absolute\";\n    ctrl.set({\n      translate: isSticky ? 0 : scrollTop < start ? start : end\n    });\n  };\n  useOnce(() => {\n    if (parent) {\n      parent.layers.add(layer);\n      parent.update();\n      return () => {\n        parent.layers.delete(layer);\n        parent.update();\n      };\n    }\n  });\n  const translate3d = ctrl.springs.translate.to(layer.horizontal ? x => `translate3d(${x}px,0,0)` : y => `translate3d(0,${y}px,0)`);\n  return /* @__PURE__ */React.createElement(a.div, {\n    ...rest,\n    ref: layerRef,\n    style: {\n      position: \"absolute\",\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      backgroundSize: \"auto\",\n      backgroundRepeat: \"no-repeat\",\n      willChange: \"transform\",\n      [layer.horizontal ? \"height\" : \"width\"]: \"100%\",\n      [layer.horizontal ? \"width\" : \"height\"]: ctrl.springs.space,\n      WebkitTransform: translate3d,\n      msTransform: translate3d,\n      transform: translate3d,\n      ...rest.style\n    }\n  });\n}));\nvar Parallax = React.memo(React.forwardRef((props, ref) => {\n  const [ready, setReady] = useState(false);\n  const {\n    pages,\n    innerStyle: _innerStyle,\n    config = configs.slow,\n    enabled = true,\n    horizontal = false,\n    children,\n    ...rest\n  } = props;\n  const containerRef = useRef();\n  const contentRef = useRef();\n  const state = useMemoOne(() => ({\n    config,\n    horizontal,\n    busy: false,\n    space: 0,\n    current: 0,\n    offset: 0,\n    controller: new Controller({\n      scroll: 0\n    }),\n    layers: /* @__PURE__ */new Set(),\n    container: containerRef,\n    content: contentRef,\n    update: () => update(),\n    scrollTo: offset => scrollTo(offset),\n    stop: () => state.controller.stop()\n  }), []);\n  useEffect(() => {\n    state.config = config;\n  }, [config]);\n  React.useImperativeHandle(ref, () => state);\n  const update = () => {\n    const container = containerRef.current;\n    if (!container) return;\n    const spaceProp = horizontal ? \"clientWidth\" : \"clientHeight\";\n    state.space = container[spaceProp];\n    const scrollType = getScrollType(horizontal);\n    if (enabled) {\n      state.current = container[scrollType];\n    } else {\n      container[scrollType] = state.current = state.offset * state.space;\n    }\n    const content = contentRef.current;\n    if (content) {\n      const sizeProp = horizontal ? \"width\" : \"height\";\n      content.style[sizeProp] = `${state.space * pages}px`;\n    }\n    state.layers.forEach(layer => {\n      layer.setHeight(state.space, true);\n      layer.setPosition(state.space, state.current, true);\n    });\n  };\n  const scrollTo = offset => {\n    const container = containerRef.current;\n    const scrollType = getScrollType(horizontal);\n    state.offset = offset;\n    state.controller.set({\n      scroll: state.current\n    });\n    state.controller.stop().start({\n      scroll: offset * state.space,\n      config,\n      onChange(_ref2) {\n        let {\n          value: {\n            scroll\n          }\n        } = _ref2;\n        container[scrollType] = scroll;\n      }\n    });\n  };\n  const onScroll = event => {\n    if (!state.busy) {\n      state.busy = true;\n      state.current = event.target[getScrollType(horizontal)];\n      raf.onStart(() => {\n        state.layers.forEach(layer => layer.setPosition(state.space, state.current));\n        state.busy = false;\n      });\n    }\n  };\n  useEffect(() => state.update());\n  useOnce(() => {\n    setReady(true);\n    const onResize = () => {\n      const update2 = () => state.update();\n      raf.onFrame(update2);\n      setTimeout(update2, 150);\n    };\n    window.addEventListener(\"resize\", onResize, false);\n    return () => window.removeEventListener(\"resize\", onResize, false);\n  });\n  const overflow = enabled ? {\n    overflowY: horizontal ? \"hidden\" : \"scroll\",\n    overflowX: horizontal ? \"scroll\" : \"hidden\"\n  } : {\n    overflowY: \"hidden\",\n    overflowX: \"hidden\"\n  };\n  return /* @__PURE__ */React.createElement(a.div, {\n    ...rest,\n    ref: containerRef,\n    onScroll,\n    onWheel: enabled ? state.stop : void 0,\n    onTouchStart: enabled ? state.stop : void 0,\n    style: {\n      position: \"absolute\",\n      width: \"100%\",\n      height: \"100%\",\n      ...overflow,\n      WebkitOverflowScrolling: \"touch\",\n      WebkitTransform: START_TRANSLATE,\n      msTransform: START_TRANSLATE,\n      transform: START_TRANSLATE_3D,\n      ...rest.style\n    }\n  }, ready && /* @__PURE__ */React.createElement(React.Fragment, null, /* @__PURE__ */React.createElement(a.div, {\n    ref: contentRef,\n    style: {\n      overflow: \"hidden\",\n      position: \"absolute\",\n      [horizontal ? \"height\" : \"width\"]: \"100%\",\n      [horizontal ? \"width\" : \"height\"]: state.space * pages,\n      WebkitTransform: START_TRANSLATE,\n      msTransform: START_TRANSLATE,\n      transform: START_TRANSLATE_3D,\n      ...props.innerStyle\n    }\n  }, /* @__PURE__ */React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, child => !child.props.sticky && child))), /* @__PURE__ */React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, child => child.props.sticky && child))));\n}));\nexport { Parallax, ParallaxLayer };","map":{"version":3,"mappings":";AAAA,YAAYA,WAAW;AACvB,SAASC,YAAYC,UAAUC,QAAQC,iBAAgC;AACvE,SAASC,YAAYC,SAASC,WAAW;AACzC,SACEC,GACAC,YAEAC,UAAUC,eACL;AAEP,IAAMC,gBAAsBZ,oBAAmB,IAAI;AAEnD,SAASa,cAAcC,YAAqB;EAC1C,OAAOA,aAAa,eAAe;AACrC;AAEA,SAASC,qBACPC,UACAC,UACiB;EACjB,MAAMC,kBAAmBC,QAAc;IACrC,IAAIA,KAAKC,MAAM;MACb,OAAOD,KAAKC,SAAepB;IAC7B;IACA,OAAOmB,SAAenB;EACxB;EAEA,OAAaA,eAASqB,IAAIL,UAAWM,SACnCJ,gBAAgBI,KAAK,IACjBP,qBAAqBO,MAAMC,MAAMP,UAAUC,QAAQ,IACnDA,SAASK,KAAK,EACpB;AACF;AAEA,IAAME,qBAAqB;AAC3B,IAAMC,kBAAkB;AA0CjB,IAAMC,gBAAsB1B,WAC3BA,iBACJ,OAEE2B,QACG;EAAA,IAFH;IAAEb;IAAYc,SAAS;IAAGC,SAAS;IAAGC,QAAQ;IAAGC;IAAQ,GAAGC;EAAK;EAIjE,MAAMC,SAAShC,WAAsBW,aAAa;EAGlD,MAAMsB,OAAO7B,WAAW,MAAM;IAC5B,IAAI8B;IACJ,IAAIJ,QAAQ;MACV,MAAMK,QAAQL,OAAOK,SAAS;MAC9BD,YAAYC,QAAQH,OAAOI;IAC7B,OAAO;MACL,MAAMC,eAAeC,KAAKC,MAAMX,MAAM,IAAII,OAAOI;MACjD,MAAMI,WAAWR,OAAOI,QAAQR,SAASS,eAAeR;MACxDK,YAAY,EAAEF,OAAOS,UAAUZ,SAASW;IAC1C;IAEA,OAAO,IAAIhC,WAAqB;MAC9B4B,OAAON,SAASE,OAAOI,QAAQJ,OAAOI,QAAQT;MAC9CO;IACF,CAAC;EACH,GAAG,EAAE;EAGL,MAAMQ,QAAQtC,WACZ,OAAO;IACLS,YACEA,eAAe,UAAaiB,SAASE,OAAOnB,aAAaA;IAC3DiB,QAAQ;IACRa,UAAU;IACVC,YAAYC,QAAQC,WAA8B;MAAA,IAAnBC,gFAAY;MACzC,IAAIjB,QAAQ;QACVkB,UAAUH,QAAQC,SAAS;MAC7B,OAAO;QACL,MAAMT,eAAeC,KAAKC,MAAMX,MAAM,IAAIiB;QAC1C,MAAML,WAAWK,SAASjB,SAASS,eAAeR;QAClDI,KAAKE,MAAM;UACTD,WAAW,EAAEY,YAAYjB,SAASW;UAClC/B,QAAQuB,OAAOvB;UACfsC;QACF,CAAC;MACH;IACF;IACAE,UAAUJ,QAA2B;MAAA,IAAnBE,gFAAY;MAC5Bd,KAAKE,MAAM;QACTC,OAAON,SAASe,SAASA,SAASlB;QAClClB,QAAQuB,OAAOvB;QACfsC;MACF,CAAC;IACH;EACF,IACA,EAAC,CACH;EAEA1C,QAAQ,MAAM;IACZ,IAAIyB,QAAQ;MACV,MAAMK,QAAQL,OAAOK,SAAS;MAC9B,MAAMe,MAAMpB,OAAOoB,OAAOf,QAAQ;MAClCO,MAAMZ,SAAS;QAAEK;QAAOe;MAAI;IAC9B;EACF,CAAC;EAEKnD,0BAAoB2B,KAAK,MAAMgB,KAAK;EAE1C,MAAMS,WAAWjD,QAAY;EAE7B,MAAM8C,YAAY,CAACH,QAAgBC,cAAsB;IACvD,MAAMX,QAAQO,MAAMZ,OAAQK,QAASU;IACrC,MAAMK,MAAMR,MAAMZ,OAAQoB,MAAOL;IACjC,MAAMF,WAAWG,aAAaX,SAASW,aAAaI;IAEpD,IAAIP,aAAaD,MAAMC,UAAU;IACjCD,MAAMC,WAAWA;IAEjB,MAAMjB,OAAMyB,SAASV;IACrBf,KAAI0B,MAAMC,WAAWV,WAAW,WAAW;IAC3CV,KAAKqB,IAAI;MACPpB,WAAWS,WAAW,IAAIG,YAAYX,QAAQA,QAAQe;IACxD,CAAC;EACH;EAGA7C,QAAQ,MAAM;IACZ,IAAI2B,QAAQ;MACVA,OAAOuB,OAAOC,IAAId,KAAK;MACvBV,OAAOyB,QAAO;MACd,OAAO,MAAM;QACXzB,OAAOuB,OAAOG,OAAOhB,KAAK;QAC1BV,OAAOyB,QAAO;MAChB;IACF;EACF,CAAC;EAED,MAAME,cAAc1B,KAAK2B,QAAQ1B,UAAU2B,GACzCnB,MAAM7B,aACFiD,KAAK,eAAeA,aACpBC,KAAK,iBAAiBA,SAC5B;EAEA,OACE,mCAACxD,EAAEyD,KAAF;IACE,GAAGjC;IACJL,KAAKyB;IACLC,OAAO;MACLC,UAAU;MACVY,KAAK;MACLC,QAAQ;MACRC,MAAM;MACNC,OAAO;MACPC,gBAAgB;MAChBC,kBAAkB;MAClBC,YAAY;MACZ,CAAC7B,MAAM7B,aAAa,WAAW,OAAO,GAAG;MACzC,CAAC6B,MAAM7B,aAAa,UAAU,QAAQ,GAAGoB,KAAK2B,QAAQxB;MACtDoC,iBAAiBb;MACjBc,aAAad;MACbe,WAAWf;MACX,GAAG5B,KAAKqB;IACV;EAAA,EACF;AAEJ,EACF,CACF;AAcO,IAAMuB,WAAiB5E,WACtBA,iBAAqC,CAACuB,OAAOI,QAAQ;EACzD,MAAM,CAACkD,OAAOC,QAAQ,IAAI5E,SAAS,KAAK;EACxC,MAAM;IACJ6E;IACAC,YAAYC;IACZvE,SAASC,QAAQuE;IACjBC,UAAU;IACVrE,aAAa;IACbE;IACA,GAAGgB;EACL,IAAIT;EAEJ,MAAM6D,eAAejF,QAAY;EACjC,MAAMkF,aAAalF,QAAY;EAE/B,MAAMmF,QAAmBjF,WACvB,OAAO;IACLK;IACAI;IACAyE,MAAM;IACNlD,OAAO;IACPK,SAAS;IACTb,QAAQ;IACR2D,YAAY,IAAI/E,WAAW;MAAEgF,QAAQ;IAAE,CAAC;IACxCjC,QAAQ,mBAAIkC,KAAoB;IAChCC,WAAWP;IACXQ,SAASP;IACT3B,QAAQ,MAAMA,QAAO;IACrBmC,UAAUhE,UAAUgE,SAAShE,MAAM;IACnCiE,MAAM,MAAMR,MAAME,WAAWM;EAC/B,IACA,EAAC,CACH;EAEA1F,UAAU,MAAM;IACdkF,MAAM5E,SAASA;EAEjB,GAAG,CAACA,MAAM,CAAC;EAELV,0BAAoB2B,KAAK,MAAM2D,KAAK;EAE1C,MAAM5B,SAAS,MAAM;IACnB,MAAMiC,YAAYP,aAAa1C;IAC/B,IAAI,CAACiD,WAAW;IAEhB,MAAMI,YAAYjF,aAAa,gBAAgB;IAC/CwE,MAAMjD,QAAQsD,UAAUI,SAAS;IAEjC,MAAMC,aAAanF,cAAcC,UAAU;IAC3C,IAAIqE,SAAS;MACXG,MAAM5C,UAAUiD,UAAUK,UAAU;IACtC,OAAO;MACLL,UAAUK,UAAU,IAAIV,MAAM5C,UAAU4C,MAAMzD,SAASyD,MAAMjD;IAC/D;IAEA,MAAMuD,UAAUP,WAAW3C;IAC3B,IAAIkD,SAAS;MACX,MAAMK,WAAWnF,aAAa,UAAU;MACxC8E,QAAQvC,MAAM4C,QAAQ,IAAI,GAAGX,MAAMjD,QAAQ0C;IAC7C;IAEAO,MAAM9B,OAAO0C,QAAQvD,SAAS;MAC5BA,MAAMO,UAAUoC,MAAMjD,OAAO,IAAI;MACjCM,MAAME,YAAYyC,MAAMjD,OAAOiD,MAAM5C,SAAS,IAAI;IACpD,CAAC;EACH;EAEA,MAAMmD,WAAYhE,UAAmB;IACnC,MAAM8D,YAAYP,aAAa1C;IAC/B,MAAMsD,aAAanF,cAAcC,UAAU;IAE3CwE,MAAMzD,SAASA;IAEfyD,MAAME,WAAWjC,IAAI;MAAEkC,QAAQH,MAAM5C;IAAQ,CAAC;IAC9C4C,MAAME,WAAWM,MAAK,CAAE1D,MAAM;MAC5BqD,QAAQ5D,SAASyD,MAAMjD;MACvB3B;MACAyF,gBAAqC;QAAA,IAA5B;UAAEC,OAAO;YAAEX;UAAO;QAAE;QAC3BE,UAAUK,UAAU,IAAIP;MAC1B;IACF,CAAC;EACH;EAEA,MAAMY,WAAYC,SAAe;IAC/B,IAAI,CAAChB,MAAMC,MAAM;MACfD,MAAMC,OAAO;MACbD,MAAM5C,UAAU4D,MAAMC,OAAO1F,cAAcC,UAAU,CAAC;MACtDP,IAAIiG,QAAQ,MAAM;QAChBlB,MAAM9B,OAAO0C,QAAQvD,SACnBA,MAAME,YAAYyC,MAAMjD,OAAOiD,MAAM5C,OAAO,EAC9C;QACA4C,MAAMC,OAAO;MACf,CAAC;IACH;EACF;EAEAnF,UAAU,MAAMkF,MAAM5B,QAAQ;EAC9BpD,QAAQ,MAAM;IACZwE,SAAS,IAAI;IAEb,MAAM2B,WAAW,MAAM;MACrB,MAAM/C,UAAS,MAAM4B,MAAM5B,QAAO;MAClCnD,IAAImG,QAAQhD,OAAM;MAClBiD,WAAWjD,SAAQ,GAAG;IACxB;IAEAkD,OAAOC,iBAAiB,UAAUJ,UAAU,KAAK;IACjD,OAAO,MAAMG,OAAOE,oBAAoB,UAAUL,UAAU,KAAK;EACnE,CAAC;EAED,MAAMM,WAAgC5B,UAClC;IACE6B,WAAWlG,aAAa,WAAW;IACnCmG,WAAWnG,aAAa,WAAW;EACrC,IACA;IACEkG,WAAW;IACXC,WAAW;EACb;EAEJ,OACE,mCAACzG,EAAEyD,KAAF;IACE,GAAGjC;IACJL,KAAKyD;IACLiB;IACAa,SAAS/B,UAAUG,MAAMQ,OAAO;IAChCqB,cAAchC,UAAUG,MAAMQ,OAAO;IACrCzC,OAAO;MACLC,UAAU;MACV8D,OAAO;MACPtE,QAAQ;MACR,GAAGiE;MACHM,yBAAyB;MACzB5C,iBAAiBhD;MACjBiD,aAAajD;MACbkD,WAAWnD;MACX,GAAGQ,KAAKqB;IACV;EAAA,GAECwB,SACC,yDACE,mCAACrE,EAAEyD,KAAF;IACCtC,KAAK0D;IACLhC,OAAO;MACL0D,UAAU;MACVzD,UAAU;MACV,CAACxC,aAAa,WAAW,OAAO,GAAG;MACnC,CAACA,aAAa,UAAU,QAAQ,GAAGwE,MAAMjD,QAAQ0C;MACjDN,iBAAiBhD;MACjBiD,aAAajD;MACbkD,WAAWnD;MACX,GAAGD,MAAMyD;IACX;EAAA,GAEA,mCAACpE,cAAc0G,UAAd;IAAuBlB,OAAOd;EAAA,GAC5BvE,qBACCC,UACCM,SAAe,CAACA,MAAMC,MAAMQ,UAAUT,MAE3C,EACF,EACA,mCAACV,cAAc0G,UAAd;IAAuBlB,OAAOd;EAAA,GAC5BvE,qBACCC,UACCM,SAAeA,MAAMC,MAAMQ,UAAUT,MAE1C,CACF,EAEJ;AAEJ,CAAC,EACH","names":["React","useContext","useState","useRef","useEffect","useMemoOne","useOnce","raf","a","Controller","config","configs","ParentContext","getScrollType","horizontal","mapChildrenRecursive","children","callback","isReactFragment","node","type","map","child","props","START_TRANSLATE_3D","START_TRANSLATE","ParallaxLayer","ref","factor","offset","speed","sticky","rest","parent","ctrl","translate","start","space","targetScroll","Math","floor","distance","current","layer","isSticky","setPosition","height","scrollTop","immediate","setSticky","setHeight","end","layerRef","style","position","set","layers","add","update","delete","translate3d","springs","to","x","y","div","top","bottom","left","right","backgroundSize","backgroundRepeat","willChange","WebkitTransform","msTransform","transform","Parallax","ready","setReady","pages","innerStyle","_innerStyle","slow","enabled","containerRef","contentRef","state","busy","controller","scroll","Set","container","content","scrollTo","stop","spaceProp","scrollType","sizeProp","forEach","onChange","value","onScroll","event","target","onStart","onResize","onFrame","setTimeout","window","addEventListener","removeEventListener","overflow","overflowY","overflowX","onWheel","onTouchStart","width","WebkitOverflowScrolling","Provider"],"sources":["/Users/isha/IdeaProjects/minted_wealth/node_modules/@react-spring/parallax/src/index.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useContext, useState, useRef, useEffect, CSSProperties } from 'react'\nimport { useMemoOne, useOnce, raf } from '@react-spring/shared'\nimport {\n  a,\n  Controller,\n  SpringConfig,\n  config as configs,\n} from '@react-spring/web'\n\nconst ParentContext = React.createContext<any>(null)\n\nfunction getScrollType(horizontal: boolean) {\n  return horizontal ? 'scrollLeft' : 'scrollTop'\n}\n\nfunction mapChildrenRecursive(\n  children: React.ReactNode,\n  callback: Function\n): React.ReactNode {\n  const isReactFragment = (node: any) => {\n    if (node.type) {\n      return node.type === React.Fragment\n    }\n    return node === React.Fragment\n  }\n\n  return React.Children.map(children, (child: any) =>\n    isReactFragment(child)\n      ? mapChildrenRecursive(child.props.children, callback)\n      : callback(child)\n  )\n}\n\nconst START_TRANSLATE_3D = 'translate3d(0px,0px,0px)'\nconst START_TRANSLATE = 'translate(0px,0px)'\n\nexport interface IParallaxLayer {\n  horizontal: boolean\n  sticky: StickyConfig\n  isSticky: boolean\n  setHeight(height: number, immediate?: boolean): void\n  setPosition(height: number, scrollTop: number, immediate?: boolean): void\n}\n\nexport interface IParallax {\n  config: ConfigProp\n  horizontal: boolean\n  busy: boolean\n  space: number\n  offset: number\n  current: number\n  controller: Controller<{ scroll: number }>\n  layers: Set<IParallaxLayer>\n  container: React.MutableRefObject<any>\n  content: React.MutableRefObject<any>\n  scrollTo(offset: number): void\n  update(): void\n  stop(): void\n}\n\ntype ViewProps = React.ComponentPropsWithoutRef<'div'>\n\ntype StickyConfig = { start?: number; end?: number } | undefined\n\nexport interface ParallaxLayerProps extends ViewProps {\n  horizontal?: boolean\n  /** Size of a page, (1=100%, 1.5=1 and 1/2, ...) */\n  factor?: number\n  /** Determines where the layer will be at when scrolled to (0=start, 1=1st page, ...) */\n  offset?: number\n  /** Shifts the layer in accordance to its offset, values can be positive or negative */\n  speed?: number\n  /** Layer will be sticky between these two offsets, all other props are ignored */\n  sticky?: StickyConfig\n}\n\nexport const ParallaxLayer = React.memo(\n  React.forwardRef<IParallaxLayer, ParallaxLayerProps>(\n    (\n      { horizontal, factor = 1, offset = 0, speed = 0, sticky, ...rest },\n      ref\n    ) => {\n      // Our parent controls our height and position.\n      const parent = useContext<IParallax>(ParentContext)\n\n      // This is how we animate.\n      const ctrl = useMemoOne(() => {\n        let translate\n        if (sticky) {\n          const start = sticky.start || 0\n          translate = start * parent.space\n        } else {\n          const targetScroll = Math.floor(offset) * parent.space\n          const distance = parent.space * offset + targetScroll * speed\n          translate = -(parent.current * speed) + distance\n        }\n        type Animated = { space: number; translate: number }\n        return new Controller<Animated>({\n          space: sticky ? parent.space : parent.space * factor,\n          translate,\n        })\n      }, [])\n\n      // Create the layer.\n      const layer = useMemoOne<IParallaxLayer>(\n        () => ({\n          horizontal:\n            horizontal === undefined || sticky ? parent.horizontal : horizontal,\n          sticky: undefined,\n          isSticky: false,\n          setPosition(height, scrollTop, immediate = false) {\n            if (sticky) {\n              setSticky(height, scrollTop)\n            } else {\n              const targetScroll = Math.floor(offset) * height\n              const distance = height * offset + targetScroll * speed\n              ctrl.start({\n                translate: -(scrollTop * speed) + distance,\n                config: parent.config,\n                immediate,\n              })\n            }\n          },\n          setHeight(height, immediate = false) {\n            ctrl.start({\n              space: sticky ? height : height * factor,\n              config: parent.config,\n              immediate,\n            })\n          },\n        }),\n        []\n      )\n\n      useOnce(() => {\n        if (sticky) {\n          const start = sticky.start || 0\n          const end = sticky.end || start + 1\n          layer.sticky = { start, end }\n        }\n      })\n\n      React.useImperativeHandle(ref, () => layer)\n\n      const layerRef = useRef<any>()\n\n      const setSticky = (height: number, scrollTop: number) => {\n        const start = layer.sticky!.start! * height\n        const end = layer.sticky!.end! * height\n        const isSticky = scrollTop >= start && scrollTop <= end\n\n        if (isSticky === layer.isSticky) return\n        layer.isSticky = isSticky\n\n        const ref = layerRef.current\n        ref.style.position = isSticky ? 'sticky' : 'absolute'\n        ctrl.set({\n          translate: isSticky ? 0 : scrollTop < start ? start : end,\n        })\n      }\n\n      // Register the layer with our parent.\n      useOnce(() => {\n        if (parent) {\n          parent.layers.add(layer)\n          parent.update()\n          return () => {\n            parent.layers.delete(layer)\n            parent.update()\n          }\n        }\n      })\n\n      const translate3d = ctrl.springs.translate.to(\n        layer.horizontal\n          ? x => `translate3d(${x}px,0,0)`\n          : y => `translate3d(0,${y}px,0)`\n      )\n\n      return (\n        <a.div\n          {...rest}\n          ref={layerRef}\n          style={{\n            position: 'absolute',\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n            backgroundSize: 'auto',\n            backgroundRepeat: 'no-repeat',\n            willChange: 'transform',\n            [layer.horizontal ? 'height' : 'width']: '100%',\n            [layer.horizontal ? 'width' : 'height']: ctrl.springs.space,\n            WebkitTransform: translate3d,\n            msTransform: translate3d,\n            transform: translate3d,\n            ...rest.style,\n          }}\n        />\n      )\n    }\n  )\n)\n\ntype ConfigProp = SpringConfig | ((key: string) => SpringConfig)\n\nexport interface ParallaxProps extends ViewProps {\n  /** Determines the total space of the inner content where each page takes 100% of the visible container */\n  pages: number\n  config?: ConfigProp\n  enabled?: boolean\n  horizontal?: boolean\n  innerStyle?: CSSProperties\n  children: React.ReactNode\n}\n\nexport const Parallax = React.memo(\n  React.forwardRef<IParallax, ParallaxProps>((props, ref) => {\n    const [ready, setReady] = useState(false)\n    const {\n      pages,\n      innerStyle: _innerStyle,\n      config = configs.slow,\n      enabled = true,\n      horizontal = false,\n      children,\n      ...rest\n    } = props\n\n    const containerRef = useRef<any>()\n    const contentRef = useRef<any>()\n\n    const state: IParallax = useMemoOne(\n      () => ({\n        config,\n        horizontal,\n        busy: false,\n        space: 0,\n        current: 0,\n        offset: 0,\n        controller: new Controller({ scroll: 0 }),\n        layers: new Set<IParallaxLayer>(),\n        container: containerRef,\n        content: contentRef,\n        update: () => update(),\n        scrollTo: offset => scrollTo(offset),\n        stop: () => state.controller.stop(),\n      }),\n      []\n    )\n\n    useEffect(() => {\n      state.config = config\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [config])\n\n    React.useImperativeHandle(ref, () => state)\n\n    const update = () => {\n      const container = containerRef.current\n      if (!container) return\n\n      const spaceProp = horizontal ? 'clientWidth' : 'clientHeight'\n      state.space = container[spaceProp]\n\n      const scrollType = getScrollType(horizontal)\n      if (enabled) {\n        state.current = container[scrollType]\n      } else {\n        container[scrollType] = state.current = state.offset * state.space\n      }\n\n      const content = contentRef.current\n      if (content) {\n        const sizeProp = horizontal ? 'width' : 'height'\n        content.style[sizeProp] = `${state.space * pages}px`\n      }\n\n      state.layers.forEach(layer => {\n        layer.setHeight(state.space, true)\n        layer.setPosition(state.space, state.current, true)\n      })\n    }\n\n    const scrollTo = (offset: number) => {\n      const container = containerRef.current\n      const scrollType = getScrollType(horizontal)\n\n      state.offset = offset\n\n      state.controller.set({ scroll: state.current })\n      state.controller.stop().start({\n        scroll: offset * state.space,\n        config,\n        onChange({ value: { scroll } }: any) {\n          container[scrollType] = scroll\n        },\n      })\n    }\n\n    const onScroll = (event: any) => {\n      if (!state.busy) {\n        state.busy = true\n        state.current = event.target[getScrollType(horizontal)]\n        raf.onStart(() => {\n          state.layers.forEach(layer =>\n            layer.setPosition(state.space, state.current)\n          )\n          state.busy = false\n        })\n      }\n    }\n\n    useEffect(() => state.update())\n    useOnce(() => {\n      setReady(true)\n\n      const onResize = () => {\n        const update = () => state.update()\n        raf.onFrame(update)\n        setTimeout(update, 150) // Some browsers don't fire on maximize!\n      }\n\n      window.addEventListener('resize', onResize, false)\n      return () => window.removeEventListener('resize', onResize, false)\n    })\n\n    const overflow: React.CSSProperties = enabled\n      ? {\n          overflowY: horizontal ? 'hidden' : 'scroll',\n          overflowX: horizontal ? 'scroll' : 'hidden',\n        }\n      : {\n          overflowY: 'hidden',\n          overflowX: 'hidden',\n        }\n\n    return (\n      <a.div\n        {...rest}\n        ref={containerRef}\n        onScroll={onScroll}\n        onWheel={enabled ? state.stop : undefined}\n        onTouchStart={enabled ? state.stop : undefined}\n        style={{\n          position: 'absolute',\n          width: '100%',\n          height: '100%',\n          ...overflow,\n          WebkitOverflowScrolling: 'touch',\n          WebkitTransform: START_TRANSLATE,\n          msTransform: START_TRANSLATE,\n          transform: START_TRANSLATE_3D,\n          ...rest.style,\n        }}\n      >\n        {ready && (\n          <>\n            <a.div\n              ref={contentRef}\n              style={{\n                overflow: 'hidden',\n                position: 'absolute',\n                [horizontal ? 'height' : 'width']: '100%',\n                [horizontal ? 'width' : 'height']: state.space * pages,\n                WebkitTransform: START_TRANSLATE,\n                msTransform: START_TRANSLATE,\n                transform: START_TRANSLATE_3D,\n                ...props.innerStyle,\n              }}\n            >\n              <ParentContext.Provider value={state}>\n                {mapChildrenRecursive(\n                  children,\n                  (child: any) => !child.props.sticky && child\n                )}\n              </ParentContext.Provider>\n            </a.div>\n            <ParentContext.Provider value={state}>\n              {mapChildrenRecursive(\n                children,\n                (child: any) => child.props.sticky && child\n              )}\n            </ParentContext.Provider>\n          </>\n        )}\n      </a.div>\n    )\n  })\n)\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}